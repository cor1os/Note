# 总结

--

### 16位

#### 寄存器

##### 4个数据寄存器

`AX` `BX` `CX` `DX`

##### 2个变址和指针寄存器

`SI` `DI`

`SP` `BP`

##### 4个段寄存器

`CS` `DS` `ES` `SS`

##### 1个指令指针寄存器

`IP`

##### 1个标志寄存器 Flags

###### 运算结果标志

`CF`(进位标志)

`PF`(奇偶标志)

`AF`(辅助进位标志)

`ZF`(零标志)

`SF`(符号标志)

`OF`(溢出标志)

###### 状态控制标志

`TF`

`IF`

`DF`

--

### 32位

#### 寄存器

##### 4个数据寄存器

`EAX`(累加器/加减乘除/输出)

`EBX`(基地址寄存器(作为存储器指针使用))

`ECX`(计数器(循环计数)/未操作中,使用`CL`指明移位位数)

`EDX`(数据寄存器/乘除时作为默认操作数/存放IO端口地址)

##### 2个变址和指针寄存器(存储偏移量)

`ESI` `EDI`

> 一般作为存储器指针使用.
> 
> 变址寄存器不可分割成8位寄存器 作为通用寄存器时也可存储算术逻辑运算的操作数和结果.
> 
> 字符串操作指令执行过程中 对它们有特定的要求 还具有特殊的功能.

`ESP` `EBP`

> 用于访问堆栈内的存储单元.
> 
> 指针寄存器不可分割成8位寄存器 作为通用寄存器时也可存储算术逻辑运算的操作数和结果.
> 
> `EBP`为基指针寄存器 直接存取堆栈数据.
> 
> `ESP`为堆栈指针寄存器 用于访问栈顶.

##### 6个段寄存器

`ECS`(代码段寄存器)

`EDS`(数据段寄存器)

`EES`(附加段寄存器(附加数据段的段值))

`ESS`(堆栈段寄存器)

`EFS`(附加段寄存器(附加数据段的段值))

`EGS`(附加段寄存器(附加数据段的段值))

> 32位CPU有两种工作方式: 实方式 保护方式
> 
> 实方式: 前4个段寄存器`CS` `DS` `ES` `SS`与先前CPU中的所对应的段寄存器的含义完全一致 内存单元的逻辑地址为"段值:偏移量"的形式. 为访问某内存段内的数据 必须使用该段寄存器和存储单元的偏移量.
> 
> 保护方式: 装入段寄存器的不再是段值 而是称为"选择子"(selector)的某个值.

##### 1个指令指针寄存器

`EIP`(存放下次将要执行的指令在代码段中的偏移量)

##### 1个标志寄存器 EFlags

###### 运算结果标志

`CF`(进位标志)

> 最高位产生了进位或借位 置1 反之置0

`PF`(奇偶标志)

> 反应运算结果中"1"的个数的奇偶性 "1"的个数为偶 则置1 反之置0

`AF`(辅助进位标志)

> 1 字操作时 低字节向高字节进位或借位时 置1 反之置0
> 
> 2 字节操作时 低4位向高4位进位或借位时 置1 反之置0

`ZF`(零标志)

> 反应运算结果是否为0 为0置1 反之置0

`SF`(符号标志)

> 运算结果为正数 置0 反之置1

`OF`(溢出标志)

> 反应有符号数加减运算所得结果是否溢出 结果超出当前运算数所能表示的范围则为溢出 置1 反之置0

###### 状态控制标志

> 状态控制标志位是用来控制CPU操作的 它们要通过专门的指令才能使之发生改变

`TF`(追踪标志)

> 当`TF`置1时 CPU进入单步执行方式 即每执行一条指令 产生一个单步中断请求. 这种方式主要用于程序调试

`IF`(中断允许标志)

> 置1时 CPU可以响应CPU外部的 可屏蔽中断 发出的中断请求
> 
> 置0时 CPU不响应CPU外部的 可屏蔽中断 发出的中断请求

`DF`(方向标志)

> 决定串操作指令执行时有关指针寄存器发生调整的方向

以下为32位标志寄存器增加的标志

`I/O`(I/O特权标志)

`NT`(嵌套任务标志)

`RF`(重启标志)

`VM`(虚拟8086方式标志)

---

#### 指令

##### 常用指令

###### 通用数据传送指令

`MOV`(传送字或字节)

`MOVSX`(先符号扩展, 再传送)

`MOVZX`(先零扩展, 再传送)

`PUSH`(把字压入堆栈)

`POP`(把字弹出堆栈)

`PUSHA`(把`AX` `CX` `DX` `BX` `SP` `BP` `SI` `DI`依次压入堆栈)

`POPA`(把`DI` `SI` `BP` `SP` `BX` `DX` `CX` `AX`依次弹出堆栈)

`PUSHAD`(把`EAX` `ECX` `EDX` `EBX` `ESP` `EBP` `ESI` `EDI`依次压入堆栈)

`POPAD`(把`EDI` `ESI` `EBP` `ESP` `EBX` `EDX` `ECX` `EAX`依次弹出堆栈)

`BSWAP`(交换32位寄存器里字节的顺序)

`XCHG`(交换字或字节(至少有一个操作数为寄存器, 段寄存器不可作为操作数))

`CMPXCHG`(比较并交换操作数(第二个操作数必须为累加器AL/AX/EAX))

`XADD`(先交换再累加(结果在第一个操作数里))

`XLAT`(字节查表转换)

> `BX`指向一张256字节的表的起点 `AL`为表的索引值(0-255, 即0-FFH). 返回`AL`为查表结果([`BX`+`AL`]==>`AL`)

###### 输入输入端口传送指令

`IN`(I/O端口输入(语法: `IN`累加器, {端口号|`DX`}))

`OUT`(I/O端口输出(语法: `OUT` {端口号|`DX`|, 累加器}))

> 输入输出端口由立即方式指定时 其范围是0-255 由寄存器`DX`制定时 其范围是0-65535

###### 目的地址传送指令

`LEA`装入有效地址

> Exp: `LEA DX, string` 把偏移地址存到`DX`

`LDS`传送目标指针 把指针内容装入`DS`

> Exp: `LDS SI, string` 把 段地址:偏移地址 存到 `DS:SI`

`LES`传送目标指针 把指针内容装入`ES`

> Exp: `LES DI, string` 把 段地址:偏移地址 存到 `ES:DI`

`LFS`传送目标指针 把指针内容装入`FS`

> Exp: `LFS DI, string` 把 段地址:偏移地址 存到 `FS:DI`

`LGS`传送目标指针 把指针内容装入`ES`

> Exp: `LGS DI, string` 把 段地址:偏移地址 存到 `GS:DI`

`LSS`传送目标指针 把指针内容装入`FS`

> Exp: `LSS DI, string` 把 段地址:偏移地址 存到 `SS:DI`

###### 标志传送指令

`LAHF`标志寄存器传送 把标志装入`AH`

`SAHF`标志寄存器传送 把`AH`内容装入标志寄存器

`PUSHF`标志入栈

`POPF`标志出栈

`PUSHD`32位标志入栈

`POPD`32位标志出栈

##### 算术运算指令

`ADD`加法

`ADC`带位加法

`INC`加1

`AAA`加法的ASCLL码调整

`DAA`加法的十进制调整

`SUB`减法

`SBB`带借位减法

`DEC`减1

`NEC`求反

`CMP`比较(两操作数作减法 仅修改标志位 不回送结果)

`AAS`减法的ASCLL码调整

`DAS`减法的十进制调整

`MUL`无符号乘法

`IMUL`整数乘法

> 以上两条 结果回送`AH`和`AL`(字节运算) 或`DX`和`AX`(字运算)

`AAM`乘法的ASCLL码调整

`DIV`无符号除法

`IDIV`整数除法

> 以上两条 结果回送
> 
> 商回送`AL` 余数回送`AH`(字节运算)
> 
> 或 商回送`AX` 余数回送`DX`(字运算)

`AAD`除法的ASCLL码调整

`CBW`字节转换为字(把`AL`中字节的符号扩展到`AH`中去)

`CWD`字转换为双字(把`AX`中的字的符号扩展到`DX`中去)

`CWDE`字转换为双子(把`AX`中的字的符号扩展到`EAX`中去)

`CDQ`双字扩展(把`EAX`中的字的符号扩展到`EDX`中去)

##### 逻辑运算指令

`AND`与运算

`OR`或运算

`XOR`异或运算

`NOT`取反

`TEST`测试(两操作数作与运算 仅修改标志位 不同回送结果)

`SHL`逻辑左移

`SAL`算术左移(`=SHL`)

`SHR`逻辑右移

`SAR`算术右移(`=SHR`)

`ROL`循环左移

`ROR`循环右移

`RCL`通过进位的循环左移

`RCR`通过进位的循环右移

> 以上8种位移指令 其位移次数可达255次
> 
> 移位1次时 可直接用操作码 如 `SHL AX, 1`
> 
> 移位大于1次时 则由寄存器`CL`给出移位次数
> 
> `MOV CL, 04`
> 
> `SHL AX, CL`

##### 串指令

`DS:SI`源串段寄存器:源串变址

`ES I`目标串段寄存器:目标串变址

`CX`重复次数计数器

`AL/AX`扫描值

D标志 0表示重复操作中`SI`和`DI`应自动增量 1表示应自动减量

Z标志 用来控制扫描或比较操作的结束

`MOVS`串传送

(`MOVSB`传送字符 `MOVSW`传送字 `MOVSD`传送双字)

`CMPS`串比较

(`CMPSB`比较字符 `CMPSW`比较字)

`SCAS`串扫描

把`AL`或`AX`的内容与目标串作比较 比较结果反映在标志位

`LODS`装入串

把源串中的元素(字或字节)逐一装入`AL`或`AX`中

(`LODS`传送字符 `LODSW`传送字 `LODSD`传送双字)

`STOS`保存串

是`LODS`的逆过程

`REP`当`CX/ECX0`时重复

`REPE/REPZ`当`ZF=1`或比较结果相等 且`CX/ECX0`时重复

`REPNE/REPNZ`当`ZF=0`或比较结果不相等 且`CX/ECX0`时重复

`REPC`当`CF=1`且`CX/ECX0`时重复

`REPNC`当`CF=0`且`CX/ECX0`时重复

##### 程序转移指令

###### 简单的条件转移指令

`JZ`(或`JE`)`OPR`    结果为零转移 测试条件`ZF=1`

`JNZ`(或`JNE`)`OPR`    结果不为零转移 测试条件`ZF=0`

`JS OPR`    结果为负转移 测试条件`SF=1`

`JNS OPR`    结果为正转移 测试条件`SF=0`

`JO OPR`    溢出转移 测试条件`OF=1`

`JNO OPR`    不溢出转移 测试条件`OF=0`

`JP OPR`    结果为偶转移 测试条件`PF=1`

`JNP OPR`    结果为奇转移 测试条件`PF=0`

`JC OPR`    有进位转移 测试条件`CF=1`

`JNC OPR`    无进位转移 测试条件`CF=0`

##### 调用子程序与返回指令

`CALL` 子程序调用指令

`RET` 子程序第返回指令

##### 其他指令

`OFFSET` 返回偏移地址

`SEG` 返回段地址

`EQU(=)` 等值语句

`PURGE` 解除语句

`DUP` 操作数字段用复制操作符

`SEGMENT,ENDS` 段定义指令

`ASSUME` 段地址分配指令

`PRG` 起始偏移地址设置指令

`$` 地址计数器的当前值

`PROC,ENDP` 过程定义语句

`NAME,TITLE,END` 过程开始结束语句

`MACRO,ENDM` 宏定义指令

`XLAT (TRANSLATE)` 换码指令

##### 条件标志

`ZF 零标志` 当结果为零时 `SF=1` 否则 `SF=0`

`AF 辅助进位标志` 运算过程中第三位有进位值 置`AF=1` 否则 `AF=0`

`PF 奇偶标志` 当结果操作数中偶数个"1" 置`PF=1` 否则 `PF=0`

`SF 符号标志` 当结果为负时 `SF=1` 否则 `SF=0· 溢出时情况例外`

`CF 进位标志` 最高有效位产生进位值 例如 执行加法指令时 `MSB` 有进位 置`CF=1` 否则 `CF=0`

`OF 溢出标志` 若操作数结果超出了机器能表示的范围 则产生溢出 置 `OF=1` 否则 `OF=0`

`ENDM` 宏定义指令

`XLAT (TRANSLATE)` 换码指令